if(length(names(current$modStep2$coefficients)) > 1){
dev = anova(current$modStep2,test="Chisq")
dev2 = dev[-1,c(-3,-4)]
if(length(dev2$Df) > 1){
dev3 = as.data.frame(apply(dev2, 2, cbind))
}else{
dev3 = as.data.frame(t(apply(dev2, 2, cbind)))
}
dev3$Variable = rownames(dev)[-1]
deviance = dev3[c(4,2,1,3)]
deviance[,2] = formatC(deviance[,2], digits = 3, format = "f")
deviance[,4] = formatC(deviance[,4], digits = 3, format = "f")
names(deviance)[4] = c("P-value")
hl = hoslem.test(current$modStep2$y, fitted(current$modStep2), g=10)
hlRes[1,1] = hl$statistic
hlRes[1,2] = hl$parameter
hlRes[1,3] = hl$p.value
hl = hoslem.test(current$modStep2$y, fitted(current$modStep2), g=10)
hlRes[1,1] = formatC(hl$statistic, digits = 3, format = "f")
hlRes[1,2] = hl$parameter
hlRes[1,3] = formatC(hl$p.value, digits = 3, format = "f")
wald = summary(current$modStep2)
wt = wald$coefficients
ci = confint(current$modStep2)
wt = cbind(wt,ci)
waldTest = as.data.frame(apply(wt, 2, formatC, digits=3, format = "f"))
names(waldTest)[4] = "p-value"
waldTest$Variable = rownames(waldTest)
waldTest = waldTest[c(7,1:6)]
rownames(waldTest) = NULL
odds = exp(cbind(OR = coef(current$modStep2), confint(current$modStep2)))
odds2 = as.data.frame(apply(odds, 2, formatC, digits = 3, format="f"))
odds2$Variable = rownames(odds2)
or = odds2[c(4,1:3)]
rownames(or) = NULL
eq = paste(formatC(coeffs[-1,1], digits = 3, format = "f"), rownames(coeffs)[-1], sep="*", collapse = " + ")
eq2 = gsub("\\+ \\-", "- ", eq)
eq3 = paste(formatC(coeffs[1,], digits = 3, format = "f"), eq2, sep = " + ")
eq4 = gsub("\\+ \\-", "- ", eq3)
logitModel = paste0("log(odds) = ", eq4)
prob=predict(current$modStep2,type=c("response"))
rocArea = as.data.frame(roc.area(current$modStep2$y, prob))[c(-2:-4)]
rocArea2 = apply(rocArea, 2, formatC, digits=3, format = "f")
auc = as.data.frame(t(rocArea2))
names(auc) = c("AUC", "p-value")
predictions = ifelse(prob > cutOff, case, control)
classificationTable = table(current$modStep2$y, predictions)
diagnostics = glm.diag(current$modStep2)
if(store == "predictions"){
predictions = as.numeric(formatC(current$modStep2$fitted.values, digits = 3, format = "f"))
}else{predictions = NULL}
if(store == "residuals"){
residuals = as.numeric(formatC(current$modStep2$residuals, digits = 3, format = "f"))
}else{residuals = NULL}
if(store == "devianceResiduals"){
devianceResiduals = as.numeric(formatC(residuals.glm(current$modStep2, type = "deviance"), digits = 3, format = "f"))
}else{devianceResiduals = NULL}
if(store == "studendizedDevianceResiduals"){
studendizedDevianceResiduals = as.numeric(formatC(diagnostics$rd, digits = 3, format = "f"))
}else{studendizedDevianceResiduals = NULL}
if(store == "pearsonResiduals"){
pearsonResiduals = as.numeric(formatC(residuals.glm(current$modStep2, type = "pearson"), digits = 3, format = "f"))
}else{pearsonResiduals = NULL}
if(store == "studendizedPearsonResiduals"){
studendizedPearsonResiduals = as.numeric(formatC(diagnostics$rp, digits = 3, format = "f"))
}else{studendizedPearsonResiduals = NULL}
if(store == "leverages"){
leverages = as.numeric(formatC(diagnostics$h, digits = 3, format = "f"))
}else{leverages = NULL}
if(store == "cook"){
cook = as.numeric(formatC(cooks.distance(current$modStep2), digits = 3, format = "f"))
}else{cook = NULL}
if(store == "dfits"){
dfits = as.numeric(formatC(ls.diag(current$modStep2)$dfits, digits = 3, format = "f"))
}else{dfits = NULL}
if(!is.null(store)){
storeList = list(Predictions = predictions, Residuals = residuals, DevianceResiduals = devianceResiduals,
StudendizedDevianceResiduals = studendizedDevianceResiduals, PearsonResiduals = pearsonResiduals,
StudendizedPearsonResiduals = studendizedPearsonResiduals, Leverages = leverages, CookDistance = cook, DFITs = dfits)
}else{storeList = NULL}
}else{
deviance = NULL
hlRes = NULL
or = NULL
waldTest = NULL
logitModel = NULL
auc = NULL
}
}
else if(modelSelection == "stepwise" && modelSelectionCriteria == "aic"){
coeffs = as.data.frame(current$modStep1$coefficients)
if(length(names(current$modStep1$coefficients)) > 1){
dev = anova(current$modStep1, test="Chisq")
dev2 = dev[-1,c(-3,-4)]
if(length(dev2$Df) > 1){
dev3 = as.data.frame(apply(dev2, 2, cbind))
}else{
dev3 = as.data.frame(t(apply(dev2, 2, cbind)))
}
dev3$Variable = rownames(dev)[-1]
deviance = dev3[c(4,2,1,3)]
deviance[,2] = formatC(deviance[,2], digits = 3, format = "f")
deviance[,4] = formatC(deviance[,4], digits = 3, format = "f")
names(deviance)[4] = c("P-value")
hl = hoslem.test(current$modStep1$y, fitted(current$modStep1), g=10)
hlRes[1,1] = formatC(hl$statistic, digits = 3, format = "f")
hlRes[1,2] = hl$parameter
hlRes[1,3] = formatC(hl$p.value, digits = 3, format = "f")
wald = summary(current$modStep1)
wt = wald$coefficients
ci = confint(current$modStep1)
wt = cbind(wt,ci)
waldTest = as.data.frame(apply(wt, 2, formatC, digits=3, format = "f"))
names(waldTest)[4] = "p-value"
waldTest$Variable = rownames(waldTest)
waldTest = waldTest[c(7,1:6)]
rownames(waldTest) = NULL
odds = exp(cbind(OR = coef(current$modStep1), confint(current$modStep1)))
odds2 = as.data.frame(apply(odds, 2, formatC, digits = 3, format="f"))
odds2$Variable = rownames(odds2)
or = odds2[c(4,1:3)]
rownames(or) = NULL
eq = paste(formatC(coeffs[-1,1], digits = 3, format = "f"), rownames(coeffs)[-1], sep="*", collapse = " + ")
eq2 = gsub("\\+ \\-", "- ", eq)
eq3 = paste(formatC(coeffs[1,], digits = 3, format = "f"), eq2, sep = " + ")
eq4 = gsub("\\+ \\-", "- ", eq3)
logitModel = paste0("log(odds) = ", eq4)
prob=predict(current$modStep1,type=c("response"))
rocArea = as.data.frame(roc.area(current$modStep1$y, prob))[c(-2:-4)]
rocArea2 = apply(rocArea, 2, formatC, digits=3, format = "f")
auc = as.data.frame(t(rocArea2))
names(auc) = c("AUC", "p-value")
predictions = ifelse(prob > cutOff, case, control)
classificationTable = table(current$modStep1$y, predictions)
diagnostics = glm.diag(current$modStep1)
if(store == "predictions"){
predictions = as.numeric(formatC(current$modStep1$fitted.values, digits = 3, format = "f"))
}else{predictions = NULL}
if(store == "residuals"){
residuals = as.numeric(formatC(current$modStep1$residuals, digits = 3, format = "f"))
}else{residuals = NULL}
if(store == "devianceResiduals"){
devianceResiduals = as.numeric(formatC(residuals.glm(current$modStep1, type = "deviance"), digits = 3, format = "f"))
}else{devianceResiduals = NULL}
if(store == "studendizedDevianceResiduals"){
studendizedDevianceResiduals = as.numeric(formatC(diagnostics$rd, digits = 3, format = "f"))
}else{studendizedDevianceResiduals = NULL}
if(store == "pearsonResiduals"){
pearsonResiduals = as.numeric(formatC(residuals.glm(current$modStep1, type = "pearson"), digits = 3, format = "f"))
}else{pearsonResiduals = NULL}
if(store == "studendizedPearsonResiduals"){
studendizedPearsonResiduals = as.numeric(formatC(diagnostics$rp, digits = 3, format = "f"))
}else{studendizedPearsonResiduals = NULL}
if(store == "leverages"){
leverages = as.numeric(formatC(diagnostics$h, digits = 3, format = "f"))
}else{leverages = NULL}
if(store == "cook"){
cook = as.numeric(formatC(cooks.distance(current$modStep1), digits = 3, format = "f"))
}else{cook = NULL}
if(store == "dfits"){
dfits = as.numeric(formatC(ls.diag(current$modStep1)$dfits, digits = 3, format = "f"))
}else{dfits = NULL}
if(!is.null(store)){
storeList = list(Predictions = predictions, Residuals = residuals, DevianceResiduals = devianceResiduals,
StudendizedDevianceResiduals = studendizedDevianceResiduals, PearsonResiduals = pearsonResiduals,
StudendizedPearsonResiduals = studendizedPearsonResiduals, Leverages = leverages, CookDistance = cook, DFITs = dfits)
}else{storeList = NULL}
}else{
deviance = NULL
hlRes = NULL
waldTest = NULL
or = NULL
logitModel = NULL
auc = NULL
}
}else{
coeffs = as.data.frame(current$coefficients)
if(length(names(current$coefficients)) > 1){
dev = anova(current,test="Chisq")
dev2 = dev[-1,c(-3,-4)]
if(length(dev2$Df) > 1){
dev3 = as.data.frame(apply(dev2, 2, cbind))
}else{
dev3 = as.data.frame(t(apply(dev2, 2, cbind)))
}
dev3$Variable = rownames(dev)[-1]
deviance = dev3[c(4,2,1,3)]
deviance[,2] = formatC(deviance[,2], digits = 3, format = "f")
deviance[,4] = formatC(deviance[,4], digits = 3, format = "f")
names(deviance)[4] = c("P-value")
hl = hoslem.test(current$y, fitted(current), g=10)
hlRes[1,1] = formatC(hl$statistic, digits = 3, format = "f")
hlRes[1,2] = hl$parameter
hlRes[1,3] = formatC(hl$p.value, digits = 3, format = "f")
wald = summary(current)
wt = wald$coefficients
if(names(which.max(table(as.data.frame(abs(wt[,1]) > abs(wt[,2]))))) == "TRUE"){
ci = confint(current)
wt = cbind(wt,ci)
waldTest = as.data.frame(apply(wt, 2, formatC, digits=3, format = "f"))
names(waldTest)[4] = "p-value"
waldTest$Variable = rownames(waldTest)
waldTest = waldTest[c(7,1:6)]
rownames(waldTest) = NULL
odds = exp(cbind(OR = coef(current), confint(current)))
odds2 = as.data.frame(apply(odds, 2, formatC, digits = 3, format="f"))
odds2$Variable = rownames(odds2)
or = odds2[c(4,1:3)]
rownames(or) = NULL
}else{
waldTest = NULL
or = NULL
}
eq = paste(formatC(coeffs[-1,1], digits = 3, format = "f"), rownames(coeffs)[-1], sep="*", collapse = " + ")
eq2 = gsub("\\+ \\-", "- ", eq)
eq3 = paste(formatC(coeffs[1,], digits = 3, format = "f"), eq2, sep = " + ")
eq4 = gsub("\\+ \\-", "- ", eq3)
logitModel = paste0("log(odds) = ", eq4)
prob=predict(current,type=c("response"))
rocArea = as.data.frame(roc.area(current$y, prob))[c(-2:-4)]
rocArea2 = apply(rocArea, 2, formatC, digits=3, format = "f")
auc = as.data.frame(t(rocArea2))
names(auc) = c("AUC", "p-value")
predictions = ifelse(prob > cutOff, case, control)
classificationTable = table(current$y, predictions)
diagnostics = glm.diag(current)
if(store == "predictions"){
predictions = as.numeric(formatC(current$fitted.values, digits = 3, format = "f"))
}else{predictions = NULL}
if(store == "residuals"){
residuals = as.numeric(formatC(current$residuals, digits = 3, format = "f"))
}else{residuals = NULL}
if(store == "devianceResiduals"){
devianceResiduals = as.numeric(formatC(residuals.glm(current, type = "deviance"), digits = 3, format = "f"))
}else{devianceResiduals = NULL}
if(store == "studendizedDevianceResiduals"){
studendizedDevianceResiduals = as.numeric(formatC(diagnostics$rd, digits = 3, format = "f"))
}else{studendizedDevianceResiduals = NULL}
if(store == "pearsonResiduals"){
pearsonResiduals = as.numeric(formatC(residuals.glm(current, type = "pearson"), digits = 3, format = "f"))
}else{pearsonResiduals = NULL}
if(store == "studendizedPearsonResiduals"){
studendizedPearsonResiduals = as.numeric(formatC(diagnostics$rp, digits = 3, format = "f"))
}else{studendizedPearsonResiduals = NULL}
if(store == "leverages"){
leverages = as.numeric(formatC(diagnostics$h, digits = 3, format = "f"))
}else{leverages = NULL}
if(store == "cook"){
cook = as.numeric(formatC(cooks.distance(current), digits = 3, format = "f"))
}else{cook = NULL}
if(store == "dfits"){
dfits = as.numeric(formatC(ls.diag(current)$dfits, digits = 3, format = "f"))
}else{dfits = NULL}
if(!is.null(store)){
storeList = list(Predictions = predictions, Residuals = residuals, DevianceResiduals = devianceResiduals,
StudendizedDevianceResiduals = studendizedDevianceResiduals, PearsonResiduals = pearsonResiduals,
StudendizedPearsonResiduals = studendizedPearsonResiduals, Leverages = leverages, CookDistance = cook, DFITs = dfits)
}else{storeList=NULL}
}else{
deviance = NULL
hlRes = NULL
waldTest = NULL
or = NULL
logitModel = NULL
auc = NULL
}
}
}
if(descriptives){
tbl = table(responseVar)
freq = as.data.frame(tbl)
freq$percent = formatC(freq$Freq/sum(freq$Freq), digits = 3, format = "f")
names(freq) = c(names(responseVar), "n", "%")
splitCon = split(df2[, !names(df2) %in% c(names(responseVar), names(categoricalInputs2))], responseVar)
splitCat = split(df2[, !names(df2) %in% c(names(responseVar), names(continiouInputs2))], responseVar)
descList = list()
freqList = list()
l = if(!is.null(length(splitCon))){length(splitCon)}else{length(splitCat)}
for(i in 1:l){
if(!is.null(continiouInputs)){
variables = colnames(splitCon[[i]])
n = ldply(splitCon[[i]], .fun = function(x) length(x))[,-1]
mean = ldply(splitCon[[i]], .fun = function(x) formatC(mean(x),digits = 3, format= "f"))[,-1]
sd = ldply(splitCon[[i]], .fun = function(x) formatC(sd(x),digits = 3, format= "f"))[,-1]
median = ldply(splitCon[[i]], .fun = function(x) formatC(median(x),digits = 3, format= "f"))[,-1]
q1 = ldply(splitCon[[i]], .fun = function(x) formatC(quantile(x, 0.25),digits = 3, format= "f"))[,-1]
q3 = ldply(splitCon[[i]], .fun = function(x) formatC(quantile(x, 0.75),digits = 3, format= "f"))[,-1]
min = ldply(splitCon[[i]], .fun = function(x) formatC(min(x),digits = 3, format= "f"))[,-1]
max = ldply(splitCon[[i]], .fun = function(x) formatC(max(x),digits = 3, format= "f"))[,-1]
group = names(splitCon)[i]
desc = as.data.frame(cbind(group, variables,n, mean, sd, median, q1, q3, min, max))
names(desc) = c(names(responseVar), "Variable", "n", "Mean", "Standard deviation", "Median", "Q1", "Q3", "Minimum", "Maximum")
descList[[i]] = desc
}
if(!is.null(categoricalInputs)){
if(dim(categoricalInputs2)[2] == 1){
tblCat = table(splitCat[[i]])
freqCat = as.data.frame(tblCat)
freqCat$percent = formatC(freqCat$Freq/sum(freqCat$Freq), digits = 3, format = "f")
group = names(splitCat)[i]
freqCat = cbind(group, freq)
names(freqCat) = c(names(responseVar), names(categoricalInputs2), "n", "%")
}else{
freqCat = apply(splitCat[[i]], 2, as.data.frame(table))
for(f in 1:length(freqCat)){
freqCat[[f]]$percent = formatC(freqCat[[f]]$value.Freq/sum(freqCat[[f]]$value.Freq), digits = 3, format = "f")
group = names(splitCat)[i]
freqCat[[f]] = cbind(group, freqCat[[f]])
names(freqCat[[f]]) = c(names(responseVar), names(freqCat)[[f]], "n", "%")
}
}
freqList[[i]] = freqCat
}else{
freqList = NULL
}}
descriptives = do.call(rbind.data.frame, descList)
if(!is.null(categoricalInputs)){
if(dim(categoricalInputs2)[2] == 1){
frequencies = do.call(rbind.data.frame, freqList)
}else{
frequencies = freqList
}
}
}
result = list(tableResult = list(FrequenciesResponse = freq, Descriptives = descriptives, Frequencies = frequencies), testResult = list(ModelSummaryList = list(CoefficientEstimates = waldTest, LogitModel = logitModel, OddsRatio = or, HosmerLemeshow = hlRes, RocAnalysis = auc, ClassificationTable = classificationTable, AnalysisOfDeviance = deviance,  Store = storeList)), plotResult = "under construction...")
return(result)
}
responseVar = "admit"
categoricalInputs = c("rank")
continiouInputs = c("gre", "gpa")
res = coreLogisticRegression(responseVar, categoricalInputs, continiouInputs , modelSelection = "stepwise", modelSelectionCriteria = "pValue", store = "predictions", alphaEnter=0.05, alphaRemove = 0.1, cutOff = 0.5, case = 1, control = 0, ModelSummary = TRUE, descriptives = TRUE, reference = "first")
res = coreLogisticRegression(responseVar, categoricalInputs, continiouInputs , modelSelection = "enter", modelSelectionCriteria = "pValue", store = "predictions", alphaEnter=0.05, alphaRemove = 0.1, cutOff = 0.5, case = 1, control = 0, ModelSummary = TRUE, descriptives = TRUE, reference = "first")
responseVar = "admit"
categoricalInputs = c("rank")
continiouInputs = c("gre", "gpa")
responseVar
responseVar  = data[, responseVar, drop=FALSE]
responseVar
head(data)
data <- read.csv("http://www.ats.ucla.edu/stat/data/binary.csv")
head(data)
responseVar = "admit"
categoricalInputs = c("rank")
continiouInputs = c("gre", "gpa")
res = coreLogisticRegression(responseVar, categoricalInputs, continiouInputs , modelSelection = "stepwise", modelSelectionCriteria = "pValue", store = "predictions", alphaEnter=0.05, alphaRemove = 0.1, cutOff = 0.5, case = 1, control = 0, ModelSummary = TRUE, descriptives = TRUE, reference = "first")
library(aod)
library(verification)
library(ResourceSelection)
library(plyr)
res = coreLogisticRegression(responseVar, categoricalInputs, continiouInputs , modelSelection = "stepwise", modelSelectionCriteria = "pValue", store = "predictions", alphaEnter=0.05, alphaRemove = 0.1, cutOff = 0.5, case = 1, control = 0, ModelSummary = TRUE, descriptives = TRUE, reference = "first")
res
full
responseVar = "admit"
categoricalInputs = c("rank")
continiouInputs = c("gre", "gpa")
responseVar  = data[, responseVar, drop=FALSE]
data[,categoricalInputs] <- lapply(data[,categoricalInputs, drop=FALSE] , factor)
if(!is.null(categoricalInputs)){
categoricalInputs2 <- data[,categoricalInputs, drop=FALSE]
}else{categoricalInputs2 = NULL}
if(!is.null(continiouInputs)){
continiouInputs2 = data[, continiouInputs, drop=FALSE]
}else{continiouInputs2 = NULL}
if(!is.null(continiouInputs2)){
df1 = cbind(responseVar, continiouInputs2)
}else{
df1 = responseVar
}
if(!is.null(categoricalInputs2)){
df2 = cbind(df1, categoricalInputs2)
}else{
df2 = df1
}
predictors = paste0(names(c(categoricalInputs2, continiouInputs2)), collapse = "+")
dependent = names(responseVar)
if(reference == "last"){
for(l in 1:dim(categoricalInputs2)[2]){
df2[, names(categoricalInputs2)[l]] <- relevel(categoricalInputs2[,l], ref = levels(categoricalInputs2[,l])[length(levels(categoricalInputs2[,l]))])
}
}
formulaFull = paste0(dependent, " ~ ", predictors)
current = glm(formula = formulaFull, data = df2, family = binomial(link="logit"))
formula = paste0(dependent, " ~ ", 1)
#scope = paste0("~ ", predictors)
coeffs = length(current$coefficients)
coeffs
d <- drop1(current, test="LRT")
pmax <- max(d[-1,5])
if (coeffs > 1) {
d <- drop1(current, test="LRT")
pmax <- max(d[-1,5])
if (pmax > alphaRemove) {
# we have a candidate for deletion
var <- rownames(d)[d[,5] == pmax];  # name of variable to delete
if (length(var) > 1) {
# if an intercept is present, it will be the first name in the list
# there also could be ties for worst p-value
# taking the second entry if there is more than one is a safe solution to both issues
var <- var[2];
}
f <- formula(current);  # current formula
f <- as.formula(paste(f[2], "~", paste(f[3], var, sep=" - ")));  # modify the formula to drop the chosen variable (by subtracting it)
current <- glm(formula = f, data = df2, family = binomial(link="logit"))  # fit the modified model
next;  # return to the top of the loop
}
}
alphaRemove=0.1
alphaEnter=0.05
if (coeffs > 1) {
d <- drop1(current, test="LRT")
pmax <- max(d[-1,5])
if (pmax > alphaRemove) {
# we have a candidate for deletion
var <- rownames(d)[d[,5] == pmax];  # name of variable to delete
if (length(var) > 1) {
# if an intercept is present, it will be the first name in the list
# there also could be ties for worst p-value
# taking the second entry if there is more than one is a safe solution to both issues
var <- var[2];
}
f <- formula(current);  # current formula
f <- as.formula(paste(f[2], "~", paste(f[3], var, sep=" - ")));  # modify the formula to drop the chosen variable (by subtracting it)
current <- glm(formula = f, data = df2, family = binomial(link="logit"))  # fit the modified model
next;  # return to the top of the loop
}
}
current
full
a <- tryCatch(add1(current, scope=full, test="LRT"), error=function(e) NULL)
a
full
full
a <- tryCatch(add1(current, scope=formulaFull, test="LRT"), error=function(e) NULL)
a
scope=formulaFull
current
a <- tryCatch(add1(current, scope=formulaFull, test="LRT"), error=function(e) NULL)
a
add1(current, scope=formulaFull, test="LRT")
add1(current, scope=full, test="LRT")
?add1.glm
add1.glm
?add1.default
add1(current, scope=full, test="LRT")
formulaFull
formula
a <- tryCatch(add1(current, scope=formulaFull, test="LRT"), error=function(e) NULL)
a
formulaFull
add1(current, scope=formulaFull, test="LRT")
current
current
formulaFull
formulaFull = paste0(dependent, " ~ ", predictors)
current = glm(formula = formulaFull, data = df2, family = binomial(link="logit"))
formula = paste0(dependent, " ~ ", 1)
#scope = paste0("~ ", predictors)
coeffs = length(current$coefficients)
current
install.packages("mvnTest")
library("mcr")
library("ICC")
set.seed(20)
x <- runif(100,0,100)
y <- 1.10*x - 0.001*x^2 + rnorm(100,0,1)*(2 + 0.05*x) + 15
data = cbind.data.frame(x,y)
variable1 = "x"
variable2 = "y"
correlation = "intraclassCorrelationCoefficient"
regression = "passingBablokRegression"
alternativeHypothesis = "equal"
confidenceLevel = 95
pairedTtest = TRUE
pooledCoefficientOfVariation = TRUE
outlierDetection = TRUE
includeConfidenceIntervalsForCorrelationCoefficients = TRUE
descriptiveStatisticsForDifferencePercentage = TRUE
descriptiveStatisticsForDifference = FALSE
if(!is.null(variable1)){
variable1 = data[, variable1, drop = FALSE]
}
if(!is.null(variable2)){
variable2 = data[, variable2, drop = FALSE]
}
if(!is.null(variable1) && !is.null(variable2)){
newData = cbind.data.frame(variable1, variable2)
}
head(newData)
ICC::ICCest(x, y, data = newData, alpha = (1-confidenceLevel/100))
class(x)
x
pnorm(2.5)
pnorm(2.5, lower.tail = T)
pnorm(2.5, lower.tail = F)
pnorm(2.5, lower.tail = F)*2
devtools::install_github("jbkunst/highcharter")
library(shiny)
?selectizeInput
install.packages("shiny")
setwd("~/Dropbox/GSD/Studies/Web-Tools(Devel)/SurvivalAnalysis/")
library(shiny)
runApp()
setwd("~/Dropbox/GSD/Studies/Web-Tools(Devel)/SurvivalAnalysis/")
library(shiny)
runApp()
setwd("~/Dropbox/GSD/Studies/Web-Tools(Devel)/refIntAminoAcid//")
library(shiny)
runApp()
setwd("~/Dropbox/GSD/Studies/Web-Tools(Devel)/SurvivalAnalysis/")
library(shiny)
runApp()
runApp()
